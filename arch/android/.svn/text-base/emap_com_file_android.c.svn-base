//----------------------------------------------------------------------------
//	emap_com_file_android.c
//	kevin.ban
// 	2008-01-20
//
//
//  port for andorid
//	uplusplus 2010-6-25
//	yjcpu@163.com
//----------------------------------------------------------------------------

#ifdef ANDROID_OS

#include <arch/emap_com_api.h>
#include <arch/emap_event_api.h>
#include <arch/emap_thread_api.h>
#include <gis/emap_gps_base.h>
//----------------------------------------------------------------------------
#ifdef DMSG
#undef DMSG
#define DMSG
#endif
//----------------------------------------------------------------------------
#define COM_MAX_INBUFSIZE	10000
#define COM_MAX_OUTBUFSIZE	10000

#define COM_BUFFER_ITEM_SIZE	128
#define COM_BUFFER_MAX_NUM		128
#define COM_BUFFER_MEM_SIZE 	(COM_BUFFER_ITEM_SIZE*(COM_BUFFER_MAX_NUM+1))

//	total memory size is: 128*128/1024=16KB

/*static e_uint8		com_buffer_mem[COM_BUFFER_MEM_SIZE];*/
static struct list_head	com_pool_head;
static e_uint32		com_pool_size;


typedef struct{
	struct	list_head list_node;
	char	data[COM_BUFFER_ITEM_SIZE];
}com_pool_data_t;



/*
 typedef struct{
 e_uint8		loc_mode;			//	定位模式：M = 手动， A = 自动。
 e_uint8		loc_type;			//	定位型式：1 = 未定位， 2 = 二维定位， 3 = 三维定位。
 e_uint8		loc_state;			//	定位状态：A=有效定位，V=无效定位
 e_uint8		gps_state;			//	GPS状态 ：0=未定位，1=非差分定位，2=差分定位，6=正在估算

 e_float32		pdop;				//	PDOP位置精度因子（0.5~99.9）
 e_float32		hdop;				//	HDOP水平精度因子（0.5~99.9）
 e_float32		vdop;				//	VDOP垂直精度因子（0.5~99.9）
 e_uint16		vnumber;			//	可见卫星的总数，00 至 12。
 e_uint16		sig_state;			//	信号新旧 GPS_NEWSIG GPS_OLDSIG
 e_uint16		ns_flag;			//	纬度半球N（北半球）或S（南半球)
 e_uint16		ew_flag;			//	经度半球E（东经）或W（西经）

 gps_gsv_vdata_t vdata[16];			//	卫星编号、仰角、方位角、信噪比信息

 e_uint32		utc_date;			//	UTC日期，ddmmyy（日月年）格式
 e_uint32		utc_time;			//	UTC时间，hhmmss（时分秒）格式
 e_float64		latitude;			//	纬度ddmm.mmmm（度分）格式（前面的0也将被传输
 e_float64		longitude;			//	经度dddmm.mmmm（度分）格式（前面的0也将被传输）
 e_float64		height;				//	海拔高度（-9999.9~99999.9）

 e_float64		mlatitude;			//	修正的纬度值，Delta参数
 e_float64		mlongitude;			//	修正的经度值，Delta参数
 e_float32		speed;				//	地面速率（000.0~999.9节，前面的0也将被传输）
 e_float32		avi_dir;			//	地面航向（000.0~359.9度，以真北为参考基准，前面的0也将被传输）

 }gps_sig_data_t;
 */

/*typedef struct{
	e_uint16	id;					//卫星编号 (范围：1 ~ 32)
	e_uint16	elevation;			//卫星仰角 (最大90)
	e_uint16	azimuth;			//卫星方位角 (绝对值，范围：0 ~ 359)
	e_uint16	dbhz;				//讯号信噪比(dBHz) 范围：0 ~ 99, 0 表未琐定
}gps_gsv_vdata_t;*/

gps_sig_data_t gps_data = {0};
struct  {
	mutex_t mutex;
	e_uint8 state;
} gps_lock = {0};


e_uint32 comm_initGpsdata(){
	if(Emap_createmutex(&gps_lock.mutex))
	{
		DMSG((STDOUT,"init gps data\n"));
		BZERO( &gps_data, gps_sig_data_t );
		gps_data.loc_mode = 'M';
		gps_data.loc_type = 2;
		gps_data.loc_state = 'V';
		gps_data.gps_state = 0;
		gps_data.sig_state = GPS_NEWSIG;
		gps_data.vnumber = 1;
		gps_lock.state = 1;
		return 1;
	}else {
		return 0;
	}

}

gps_sig_data_t *start_update_gpsdata(){
	if (!gps_lock.state) {
		if(!comm_initGpsdata()){
			return 0;
		}
	}
	if (Emap_mutexlock(&gps_lock.mutex)) {
		return &gps_data;
	}else {
		return 0;
	}

}

void end_update_gpsdata(){
	Emap_mutexunlock(&gps_lock.mutex);
}


static void
comm_init_pool( e_uint8 *mem, e_uint32 mem_size, struct list_head *free_list_head )
{
	e_uint8 *com_mem;
	e_uint32 avail_mem_size, data_mem_size;
	// set
	com_mem				= mem;
	avail_mem_size		= mem_size;
	data_mem_size		= ALIGN(sizeof(com_pool_data_t));
	com_pool_size		= 0;
	
	INIT_LIST_HEAD(free_list_head);

	// dispose
	while (avail_mem_size >= data_mem_size){
		com_pool_data_t *data = (com_pool_data_t *)com_mem;
		
		// add to list		
		list_add_before(&data->list_node, free_list_head);
        
		com_mem		    += data_mem_size;
		avail_mem_size	-= data_mem_size;
		com_pool_size++;
	}

}

static com_pool_data_t *
comm_alloc_data( struct list_head *free_list_head )
{
	 com_pool_data_t *data;
	 //	1 get next storage data nd add before head
	 data = list_entry(free_list_head->next,com_pool_data_t,list_node);
	 list_del(free_list_head->next);
	 list_add_before(&data->list_node,free_list_head);
	 return data;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
e_uint8		
Comm_Open( com_t *com, const char* com_name )
{
	/*DMSG((STDOUT,"Disable GPS!!!!!!!!!!"));
	return 0;*/
	com->state = TRUE;
	com->ready = TRUE;
	return 1;
}

void				
Comm_Close( com_t *com )
{
	BZERO( com, com_t );
	return;
}

e_uint8 
Comm_State( com_t *com )
{
	return (com?com->state:0);
}

//	attach and detach thread object
ethread_t *
Comm_Attach( com_t *com, ethread_t *thread )
{
	 ethread_t *old;
	 old = com->thread;
	 com->thread = thread;
	 return old;
}

void			
Comm_Detach( com_t *com )
{
	 if( !Comm_State(com) )
	 return;
	 com->thread = 0x0;
}

//	get/set comm state
e_bool 		
Comm_GetData( com_t *com, com_dcb_t *dcb )
{
	if( !Comm_State(com) || !dcb )
		return FALSE;
}

e_bool 	
Comm_SetData( com_t *com, const com_dcb_t *dcb )
{

	if( !Comm_State(com)|| !dcb )
		return 0;
	com->dcb = *dcb;
	return 1;

}

//	get/set comm monitored mask
e_uint32 	
Comm_SetMask( com_t *com, e_uint32 mask )
{
	return 1;
}

e_uint32	
Comm_GetMask( com_t *com )
{
	return 1;
}

//	clear comm output/input
e_bool		
Comm_Purge( com_t *com, e_uint32 flag )
{
	return 1;
}

//	read comm data
/*e_uint32
Comm_Read( com_t *com, e_uint8 *buffer, e_uint32 blen )
{
	DMSG((STDOUT,"gps comm read\n"));
	gps_sig_data_t* p_data = start_update_gpsdata();
	while ( !gps_data.gps_state || (p_data->loc_state != 'A') ) {
		end_update_gpsdata();
		Emap_Delay(100);
		p_data = start_update_gpsdata();
	}


	DMSG((STDOUT,"gps_state == %d longitude %f , latitude %f\n",p_data->gps_state,
			p_data->longitude, p_data->latitude));
	memcpy(buffer, p_data, sizeof(gps_sig_data_t));
	end_update_gpsdata();
	Just simulate as real com does
	Emap_Delay(100);
	or should update location right ,or wait for system update
	//p_data->loc_state = 'V';

	return sizeof(gps_sig_data_t);
}*/


e_uint32		
Comm_Read( com_t *com, e_uint8 *buffer, e_uint32 blen )
{
	DMSG((STDOUT,"gps comm read\n"));
	gps_sig_data_t* p_data = start_update_gpsdata();
	//while ( !gps_data.gps_state || (p_data->loc_state != 'A') ) {
	while ( !gps_data.gps_state ) {
		end_update_gpsdata();
		Emap_Delay(100);
		p_data = start_update_gpsdata();
	}


	DMSG((STDOUT,"gps_state == %d longitude %f , latitude %f s_num=%d\n",p_data->gps_state,
			p_data->longitude, p_data->latitude, p_data->vnumber));
	memcpy(buffer, p_data, sizeof(gps_sig_data_t));
	p_data->gps_state = 0;
	end_update_gpsdata();
	/*Just simulate as real com does*/
	//Emap_Delay(100);
	/*or should update location right ,or wait for system update*/

	return sizeof(gps_sig_data_t);
}

//	write comm data
e_uint32
Comm_Write( com_t *com, unsigned char *buffer, unsigned long len )
{
	DMSG((STDOUT,"gps comm write\n"));
	return len;
}

#endif	/*ANDROID_OS*/
//----------------------------------------------------------------------------
//


