/** pthread functions for ANDROID platform
 * author: vmlinz
 * email: vmlinz@gmail.com
 * date: 20100517
 *
 * NOTE: link to android bionic libc which contains librt and libpthread
 * which is different from traditional unix-like oses
 */

#ifdef ANDROID_OS

#include <arch/emap_timer_api.h>
#include <arch/emap_event_api.h>
#include <arch/emap_thread_api.h>
#include "../emap_inter_thread.h"

#include <pthread.h>	/* posix threads & posix mutexes */
#include <signal.h>	/* signal kill */
#include <semaphore.h>	/* posix semaphores */
#include <stdio.h>
#include <unistd.h>	/* posix definitions */
#include <sched.h>	/* pthread priority setting */

#ifdef DMSG
#include <android/log.h>
#undef DMSG
#define DMSG
#endif

extern thread_man_t thread_man;
//extern e_uint8 thread_mem[THREAD_MEM_SIZE];

static void _private_thread_main(ethread_t *thread)
{
	while(thread->state != EMAP_THREAD_START)
	{
		//DMSG((STDOUT,"thread in suspend state"));
		Emap_Delay(1);
	}
	DMSG((STDOUT,"thread resumed"));
	thread->state = EMAP_THREAD_RUN;
	thread->func(thread->data);

	thread->state = EMAP_THREAD_EXIT;
	/* if thread pipes are created, close them and free space */
	if(thread->queue){
		close(((int*)(thread->queue))[0]);
		close(((int*)(thread->queue))[1]);
		free((int*)thread->queue);
	}
	DMSG((STDOUT, "线程结束 thread %s", thread->name));
	/* THREAD_DEL_DATA(THREAD, &THREAD_MAN);   //doing this for what?
	THREAD_FREEDATA(THREAD, &THREAD_MAN); */
}

/*
 * emap_createthread
 * create thread.
 */
e_uint32
Emap_createthread(const char *name, thread_func func,
		 void *data, e_uint32 priority, ethread_t **thread)
{
	e_int32 thread_ret = 0;
	ethread_t *this_thread = NULL;

	pthread_attr_t athread_attr = {0};
	struct sched_param athread_schedparam = {0};

	/* 1 check thread man state */
	/* 2 alloc a thread node and set data */
	/* 3 create system thread */
	/* 4 malloc thread stack space and create task */

	/* check thread pool state */
	if( g_thread_man.state!=TRUE ){
		INIT_LIST_HEAD( &g_thread_man.used_list_head );
		g_thread_man.state = TRUE;
	}
	
	/* alloc a thread node and set data */
	E_MALLOC( ALIGN(sizeof(ethread_t)), this_thread, ethread_t );
	if(this_thread == 0x0){
		DMSG((STDOUT, "allocating mem for thread from pool\n"));
		return 0x0;
	}
	this_thread->thread_id = 0;
	/* set thread priority */
	pthread_attr_init(&athread_attr);
	if(pthread_attr_getschedparam(&athread_attr, &athread_schedparam)){
		return 0;
	}
	athread_schedparam.sched_priority = priority;
	if(pthread_attr_setschedparam(&athread_attr, &athread_schedparam)){
		return 0;
	}

	/* create pthread */
	this_thread->priority = priority;
	this_thread->data = data;
	this_thread->func = func;
	this_thread->state = EMAP_THREAD_PAUSE;
	strcpy(this_thread->name, name);

	if(pthread_create(&(this_thread->thread_id), &athread_attr,
			  (void*)_private_thread_main, this_thread) !=0)
	{
		goto exit;
	}
	DMSG((STDOUT, "创建线程: %s", name));
	/* create thread communication pipe */
	int* pipe_fds = (int*)calloc(2, sizeof(int));

	if(!pipe(pipe_fds) && pipe_fds){
		this_thread->queue = (void*)pipe_fds;
		DMSG((STDOUT,"Pipe pointer: %p",this_thread->queue));
	}
	else
	{
		DMSG((STDOUT,"Pipe failed"));
		goto exit;
	}

	list_add_before( &this_thread->list_node, &g_thread_man.used_list_head );
	*thread = this_thread;
	g_thread_man.cur_num ++;
	
	DMSG((STDOUT,
	      "create thread %s succeeded:(id %d,prio %d,thread:%p)\n",
	      name, this_thread->thread_id,
	      this_thread->priority, this_thread));
	return this_thread->thread_id;
	
exit:
	if( this_thread ){
		E_FREE( this_thread );
		this_thread = NULL;
	}
	return 0;
}

/** Emap_threadstate
 * get thread state
 */
e_uint32
Emap_threadstate(ethread_t *thread)
{
	if(thread == 0x0)
		return 0;

	return thread->state;
}

/*
 * emap_killthread
 * kill the specified thread.
 */
void
Emap_killthread(ethread_t *thread)
{
	int count = 4;
	/* 1 check thread state */
	/* 2 delete thread in system */
	/* 3 clean up itc data witch belongs to the thread */
	/* 4 free memory and thread node */

	if(!Emap_threadstate(thread) || thread == 0x0){
		DMSG((STDOUT,"killing ems thread\n"));
		return;
	}

	/* post quit event to the specified thread */
	Emap_PostThreadEvent(thread, EMAP_QUIT, 0, 0);
	do{
		Emap_Delay( 100 );
	}while(--count>0);
/*	 if thread pipes are created, close them and free space
	 if(thread->queue){
	 close(((int*)(thread->queue))[0]);
	 close(((int*)(thread->queue))[1]);
	 free((int*)thread->queue);
	 }
*/
//	free memory and thread node
	list_del( &thread->list_node );
	E_FREE( thread );

	g_thread_man.cur_num --;
	(g_thread_man.cur_num<=0)?(g_thread_man.cur_num=0):(0);
	DMSG((STDOUT,"success to destroy thread\r\n"));
}

/** emap_suspendthread:
 * suspends the specified thread.
 */
e_uint32
Emap_suspendthread(ethread_t *thread)
{
	if(!Emap_threadstate(thread) || thread == 0x0){
		DMSG((STDOUT,"thread has killed, or does not created yet\n"));
		return 0;
	}

	if(thread->state == EMAP_THREAD_PAUSE){
		DMSG((STDOUT,"current thread is in Suspend state\n"));
		return 1;
	}

	DMSG((STDOUT, "success to suspend thread \n"));
	thread->state = EMAP_THREAD_PAUSE;
	return 1;
}

/** emap_resumethread:
 * decrements a thread's suspend count,When the suspend count
 * is decremented to zero, the execution of the thread is resumed.
 */
e_uint32
Emap_resumethread(ethread_t *thread)
{

	if(!Emap_threadstate(thread) || thread == 0x0){
		DMSG((STDOUT,"thread has killed, or not created yet\n"));
		return 0;
	}

	if(thread->state == EMAP_THREAD_RUN){
		DMSG((STDOUT,"current thread is in Running state\n"));
		return 0;
	}

	if(thread->state == EMAP_THREAD_PAUSE){
		thread->state = EMAP_THREAD_START;
		DMSG((STDOUT, "success to resume thread\n"));
		return 0;
	}

	return 1;
}

/** emap_holdthread:
 */
e_uint32
Emap_holdthread(ethread_t *thread)
{
	if(!Emap_threadstate(thread) || thread == 0x0){
		DMSG((STDOUT,"thread has killed, or does not created yet\n"));
		return 0;
	}

	if(thread->state == EMAP_THREAD_HOLD){
		DMSG((STDOUT,"current thread is in Holding state\n"));
		return 1;
	}

	if(thread->state == EMAP_THREAD_START){
		DMSG((STDOUT,"current thread is in ready state\n"));
		return 1;
	}
	DMSG((STDOUT,"success to hold thread\n"));

	thread->state = EMAP_THREAD_HOLD;

	Emap_PostThreadEvent(thread, EMAP_QUIT, 0, 0);
	return 1;
}


/** emap_getthreadid
 * get current thread id
 */
e_uint32
Emap_getthreadid(ethread_t *thread)
{
	if(!Emap_threadstate(thread))
		return 0;

	return thread->thread_id;
}

/** Emap_semaphorestate
 * check semaphore success of failed state
 */
e_uint8
Emap_semaphorestate(semaphore_t *semaphore)
{
	return (semaphore->state == 1)?1:0;
}

/** emap_createsemaphore
 * create a semaphore
 */
e_uint8
Emap_createsemaphore(e_int32 init_value, semaphore_t *semaphore)
{
	sem_t *psem = calloc(1, sizeof(sem_t));
	/* 1 create system semaphore */
	/* 2 set semaphore value */
	if(init_value<0){
		DMSG((STDOUT, "system semaphore exist\n"));
		return 0;
	}

	BZERO(semaphore, semaphore_t);

	/* create system semaphore */
	/* set semaphore value */
	if(!sem_init(psem, 0, init_value)){
		semaphore->priv = psem;
		semaphore->init_value = init_value;
		semaphore->state = 1;

		DMSG((STDOUT,"success to create system semaphore\n"));
		return 1;
	}
	return 0;
}


/** emap_destroysemaphore
 * destroy a semaphore
 */
void
Emap_destroysemaphore(semaphore_t *semaphore)
{
	if(!Emap_semaphorestate(semaphore)){
		DMSG((STDOUT, "fail to destroy a semaphore\n"));
		return;
	}

	sem_destroy((sem_t *)semaphore->priv);
	free(semaphore->priv);

	DMSG((STDOUT,"succeed to destroy system semaphore\n"));
	BZERO(semaphore, semaphore_t );
}

/** emap_sempost
 * Unlock a semaphore
 */
e_int32
Emap_sempost(semaphore_t *semaphore, int count)
{
	if(!Emap_semaphorestate(semaphore)){
		DMSG((STDOUT, "post an empty or destroyed semaphore\n"));
		return 0;
	}

	DMSG((STDOUT,"succeed to post semaphore\n"));
	return sem_post((sem_t*)semaphore->priv);
}

/** emap_semwait
 * Lock a semaphore and suspend the thread if the semaphore value is zero
 */
e_int32
Emap_semwait(semaphore_t *semaphore, e_uint32 flag)
{
	if(!Emap_semaphorestate(semaphore)){
		DMSG((STDOUT, "wait on an empty or destroyed semaphore\n"));
		return 0;
	}

	sem_wait((sem_t*)semaphore->priv);
	DMSG((STDOUT,"succeed to wait semaphore\n"));
	return 1;
}

/** emap_createmutex
 * create a mutex
 */
e_uint32
Emap_createmutex(mutex_t *mutex)
{
	pthread_mutex_t *pmutex = calloc(1, sizeof(pthread_mutex_t));

	/* 1 create system mutex */
	BZERO( mutex, mutex_t );
	/* 2 set the data */
	pthread_mutex_init(pmutex, 0x0);
	mutex->priv = pmutex;
	mutex->state = 1;
	DMSG((STDOUT,"mutex created:%p", mutex->priv));
	return 1;
}

/** Emap_mutexstate
 * query state of mutex
 */
e_uint32
Emap_mutexstate(mutex_t *mutex)
{
	return (mutex->state==1)?1:0;
}

/** emap_destroymutex
 * destroy a mutex
 */
void
Emap_destroymutex(mutex_t *mutex)
{
	if(!Emap_mutexstate(mutex)){
		DMSG((STDOUT,"mutex hasn't been inited yet\n"));
		return;
	}

	DMSG((STDOUT,"destroying pthread mutex %p", mutex->priv));
	pthread_mutex_destroy(mutex->priv);
	free(mutex->priv);

	BZERO(mutex, mutex_t);
	DMSG((STDOUT,"destroy mutex successfully\n"));
}

/** emap_mutexlock
 * lock mutex
 */
e_uint32
Emap_mutexlock(mutex_t *mutex)
{
	if(!Emap_mutexstate(mutex)){
		DMSG((STDOUT,"emap_mutexlock-->>mutex does not init yet\n"));
		return 0;
	}

	pthread_mutex_lock(mutex->priv);
	DMSG((STDOUT,"success to lock mutex\n"));
	return 1;
}

/** emap_mutexunlock
 * unlock mutex
 */
e_uint32
Emap_mutexunlock(mutex_t *mutex)
{
	if(!Emap_mutexstate(mutex)){
		DMSG((STDOUT,"emap_mutexunlock-->>mutex does not init yet\n"));
		return 0;
	}

	pthread_mutex_unlock(mutex->priv);
	DMSG((STDOUT,"success to unlock mutex\n"));
	return 1;
}

#endif /* ANDROID_OS */
